name: Generate Types and Publish Package

on:
  push:
    branches: [ master ]
    paths-ignore:
      - 'ntoskrnlib/Generated/**'
  workflow_dispatch:
    inputs:
      version:
        description: 'Optional explicit version (overrides computed)'
        required: false
  schedule:
    - cron: '0 6 * * *'

jobs:
  version:
    name: Compute base version
    runs-on: ubuntu-latest
    outputs:
      base: ${{ steps.set.outputs.base }}
      latest: ${{ steps.set.outputs.latest }}
      label: ${{ steps.set.outputs.label }}
      explicit: ${{ steps.set.outputs.explicit }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Removed convco dependency; compute label via git log

      - name: Compute base version
        id: set
        shell: bash
        env:
          INPUT_VERSION: ${{ inputs.version }}
        run: |
          set -euo pipefail
          pkg=ntoskrnlib
          url="https://api.nuget.org/v3-flatcontainer/$pkg/index.json"
          if command -v jq >/dev/null 2>&1; then
            latest=$(curl -fsSL "$url" | jq -r '[.versions[] | select(test("-")|not)][-1] // "0.0.0"')
          else
            json=$(curl -fsSL "$url" || echo '{}')
            latest=$(printf '%s' "$json" | tr -d '\n\r ' | sed 's/.*"versions":\[\(.*\)\].*/\1/' | tr ',' '\n' | tr -d '"' | grep -v '-' | tail -n 1)
            latest=${latest:-0.0.0}
          fi
          label=none
          if [ "${GITHUB_EVENT_NAME}" = "push" ]; then
            git tag --list 'v*' | grep -q . || git tag v0.0.0
            last=$(git describe --tags --abbrev=0 --match 'v*' 2>/dev/null || echo v0.0.0)
            range="$last..HEAD"
            if git log --format=%s%b "$range" | grep -Ei '(^|[^A-Za-z])BREAKING CHANGE' -q \
               || git log --format=%s "$range" | grep -Ei '^[a-z]+!:' -q; then
              label=major
            elif git log --format=%s "$range" | grep -Ei '^feat(\(|:)' -q; then
              label=minor
            else
              label=none
            fi
          fi
          if [ -n "${INPUT_VERSION:-}" ]; then
            echo "explicit=true" >> $GITHUB_OUTPUT
            echo "base=$INPUT_VERSION" >> $GITHUB_OUTPUT
            echo "latest=$latest" >> $GITHUB_OUTPUT
            echo "label=$label" >> $GITHUB_OUTPUT
            exit 0
          fi
          IFS=. read -r maj min pat <<< "$latest"
          maj=${maj:-0}; min=${min:-0}; pat=${pat:-0}
          case "$label" in
            major) maj=$((maj+1)); min=0; pat=0;;
            minor) min=$((min+1)); pat=0;;
            *) :;;
          esac
          base="$maj.$min.$pat"
          echo "explicit=false" >> $GITHUB_OUTPUT
          echo "base=$base" >> $GITHUB_OUTPUT
          echo "latest=$latest" >> $GITHUB_OUTPUT
          echo "label=$label" >> $GITHUB_OUTPUT

  build:
    name: Build, generate, compare
    runs-on: windows-latest
    needs: version
    permissions:
      contents: read
    outputs:
      version: ${{ steps.out.outputs.version }}
      changed: ${{ steps.out.outputs.changed }}
      is_new: ${{ steps.out.outputs.is_new }}
    env:
      DOTNET_NOLOGO: true
      DOTNET_CLI_TELEMETRY_OPTOUT: true
      PKG_ID: ntoskrnlib
      AUTO_APPROVE_TOKEN: ${{ secrets.AUTO_APPROVE_TOKEN }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '9.0.x'

      - name: Prepare symbol tooling (PATH and cache)
        shell: pwsh
        run: |
          $cache = Join-Path $env:RUNNER_TEMP 'symbols'
          New-Item -ItemType Directory -Force -Path $cache | Out-Null
          "_NT_SYMBOL_PATH=srv*$cache*https://msdl.microsoft.com/download/symbols" | Out-File -Append -FilePath $env:GITHUB_ENV
          $candidates = @(
            "$Env:ProgramFiles(x86)\Windows Kits\10\Debuggers\x64",
            "$Env:ProgramFiles\Windows Kits\10\Debuggers\x64",
            "$Env:ProgramFiles(x86)\Windows Kits\10\Debuggers\x86"
          )
          foreach ($p in $candidates) { if (Test-Path $p) { $p | Out-File -Append -FilePath $env:GITHUB_PATH; Write-Host "Added to PATH: $p" } }

      - name: Ensure DIA (msdia140.dll) is present and registered
        shell: pwsh
        run: |
          function Register-Dia($dlls) {
            foreach ($dll in $dlls) {
              try {
                if (Test-Path $dll) {
                  Start-Process regsvr32.exe -ArgumentList '/s', $dll -Wait -NoNewWindow
                  Write-Host "Registered DIA: $dll"
                }
              } catch { Write-Warning "Failed to register $dll: $_" }
            }
          }

          $search = @(
            "$Env:ProgramFiles(x86)\Microsoft Visual Studio\2022\*\DIA SDK\bin\amd64\msdia140.dll",
            "$Env:ProgramFiles(x86)\Microsoft Visual Studio\2022\*\Common7\IDE\msdia140.dll",
            "$Env:ProgramFiles(x86)\Microsoft Visual Studio\2022\*\Common7\Packages\Debugger\msdia140.dll",
            "$Env:ProgramFiles(x86)\Microsoft Visual Studio\2022\*\Team Tools\Dynamic Code Coverage Tools\amd64\msdia140.dll",
            "$Env:ProgramFiles(x86)\Microsoft Visual Studio\2019\*\DIA SDK\bin\amd64\msdia140.dll",
            "$Env:ProgramFiles(x86)\Microsoft Visual Studio\2019\*\Common7\IDE\msdia140.dll",
            "$Env:ProgramFiles(x86)\Microsoft Visual Studio\2019\*\Common7\Packages\Debugger\msdia140.dll"
          )
          $found = @()
          foreach ($pat in $search) { $found += Get-ChildItem -Path $pat -ErrorAction SilentlyContinue }

          if (-not $found) {
            Write-Warning "msdia140.dll not found; installing Visual Studio Build Tools (VCTools workload) to obtain DIA SDK..."
            $bt = Join-Path $env:RUNNER_TEMP 'vs_BuildTools.exe'
            Invoke-WebRequest -Uri 'https://aka.ms/vs/17/release/vs_BuildTools.exe' -OutFile $bt -UseBasicParsing
            & $bt --quiet --wait --norestart --nocache \
              --add Microsoft.VisualStudio.Workload.VCTools \
              --add Microsoft.VisualStudio.Component.VC.140 \
              --includeRecommended
            # Re-scan after install
            foreach ($pat in $search) { $found += Get-ChildItem -Path $pat -ErrorAction SilentlyContinue }
          }

          if ($found) {
            Register-Dia ($found | Select-Object -ExpandProperty FullName -Unique)
          } else {
            Write-Error 'Failed to locate msdia140.dll even after attempting Build Tools install.'
          }

      - name: Build library (triggers generation)
        run: dotnet build ntoskrnlib\ntoskrnlib.csproj -c Release /p:WindowsVersionLabel=${{ env.WINVER_LABEL }}

      - name: Verify generated files exist
        shell: pwsh
        run: |
          $root = 'ntoskrnlib\\Generated'
          $base = if ('${{ env.WINVER_LABEL }}') { Join-Path $root '${{ env.WINVER_LABEL }}' } else { $root }
          $files = Get-ChildItem $base -Recurse -Filter *.g.cs -ErrorAction SilentlyContinue
          $count = @($files).Count
          Write-Host "Generated files count: $count"
          if ($count -eq 0) { Write-Error 'No generated files found in ntoskrnlib\\Generated. Failing build.'; exit 1 }
      - name: Pack with base version
        shell: pwsh
        run: |
          $verBase = '${{ needs.version.outputs.base }}'
          dotnet pack ntoskrnlib\ntoskrnlib.csproj -c Release -o artifacts /p:PackageVersion=$verBase /p:WindowsVersionLabel=${{ env.WINVER_LABEL }}

      - name: Compare content and finalize version
        id: out
        shell: pwsh
        run: |
          $pkg = "$Env:PKG_ID"
          $latest = '${{ needs.version.outputs.latest }}'
          $base = '${{ needs.version.outputs.base }}'
          $explicit = '${{ needs.version.outputs.explicit }}'

          $newDll = (Get-ChildItem -Path 'ntoskrnlib\\bin\\Release' -Recurse -Filter 'ntoskrnlib.dll' | Sort-Object LastWriteTime -Descending | Select-Object -First 1).FullName
          $contentChanged = $true
          if ($latest -ne '0.0.0') {
            $nupkgUrl = "https://api.nuget.org/v3-flatcontainer/$pkg/$latest/$pkg.$latest.nupkg"
            $nupkg = Join-Path $env:RUNNER_TEMP 'prev.nupkg'
            try {
              Invoke-WebRequest $nupkgUrl -OutFile $nupkg -UseBasicParsing
              $extract = Join-Path $env:RUNNER_TEMP 'prev'
              Expand-Archive -Path $nupkg -DestinationPath $extract -Force
              $prevDll = Get-ChildItem -Path (Join-Path $extract 'lib') -Recurse -Filter 'ntoskrnlib.dll' | Select-Object -First 1 | ForEach-Object { $_.FullName }
              if ($prevDll -and (Test-Path $newDll)) {
                $h1 = (Get-FileHash -Algorithm SHA256 $prevDll).Hash
                $h2 = (Get-FileHash -Algorithm SHA256 $newDll).Hash
                $contentChanged = ($h1 -ne $h2)
              }
            } catch { $contentChanged = $true }
          }

          $final = $base
          if ($explicit -ne 'true') {
            if ($base -eq $latest -and $contentChanged) {
              $maj,$min,$pat = ($base -split '\.')
              $final = "$maj.$min.$([int]$pat + 1)"
            }
          }

          if ($final -ne $base) {
            Remove-Item artifacts\*.nupkg -Force -ErrorAction SilentlyContinue
            dotnet pack ntoskrnlib\ntoskrnlib.csproj -c Release -o artifacts /p:PackageVersion=$final /p:WindowsVersionLabel=${{ env.WINVER_LABEL }}
          }

          $idx = Invoke-RestMethod -UseBasicParsing -Uri ("https://api.nuget.org/v3-flatcontainer/$pkg/index.json")
          $isNew = $true
          try { $isNew = -not [bool](@($idx.versions) -contains $final) } catch { $isNew = $true }

          echo "version=$final" >> $env:GITHUB_OUTPUT
          echo "changed=$contentChanged" >> $env:GITHUB_OUTPUT
          echo "is_new=$isNew" >> $env:GITHUB_OUTPUT

      - name: Upload package artifact
        uses: actions/upload-artifact@v4
        with:
          name: nupkg
          path: artifacts/*.nupkg

      - name: Create update branch
        if: steps.out.outputs.changed == 'true'
        id: br
        shell: bash
        run: |
          ts=$(date +%Y%m%d-%H%M%S)
          br="update/generated-$ts"
          echo "name=$br" >> $GITHUB_OUTPUT
          git checkout -b "$br"

      - name: Commit generated changes (if any)
        if: steps.out.outputs.changed == 'true'
        id: commit
        shell: bash
        run: |
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git config user.name "github-actions[bot]"
          git add ntoskrnlib/Generated || true
          if git diff --cached --quiet; then
            echo "changed=false" >> $GITHUB_OUTPUT
            echo "No changes to commit"
            exit 0
          fi
          git commit -m "chore(gen): update generated sources for v${{ steps.out.outputs.version }} [skip ci]"
          git push --set-upstream origin "${{ steps.br.outputs.name }}"
          echo "changed=true" >> $GITHUB_OUTPUT

      - name: Create pull request
        if: steps.commit.outputs.changed == 'true'
        id: cpr
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          branch: ${{ steps.br.outputs.name }}
          title: "chore(gen): update generated sources for v${{ steps.out.outputs.version }}"
          body: |
            Automated update of generated sources.
            Version: `${{ steps.out.outputs.version }}`
          labels: auto-merge
          draft: false

      - name: Auto-approve pull request (optional)
        if: ${{ steps.cpr.outputs.pull-request-number && env.AUTO_APPROVE_TOKEN != '' }}
        uses: hmarr/auto-approve-action@v3
        with:
          pull-request-number: ${{ steps.cpr.outputs.pull-request-number }}
        env:
          GITHUB_TOKEN: ${{ env.AUTO_APPROVE_TOKEN }}

      - name: Enable auto-merge (optional)
        if: ${{ steps.cpr.outputs.pull-request-number && env.AUTO_APPROVE_TOKEN != '' }}
        uses: peter-evans/enable-pull-request-automerge@v3
        with:
          token: ${{ env.AUTO_APPROVE_TOKEN }}
          pull-request-number: ${{ steps.cpr.outputs.pull-request-number }}
          merge-method: squash

  publish:
    name: Publish package
    runs-on: ubuntu-latest
    needs: build
    if: ${{ needs.build.outputs.changed == 'true' && needs.build.outputs.is_new == 'true' }}
    permissions:
      contents: write
    steps:
      - name: Download package
        uses: actions/download-artifact@v4
        with:
          name: nupkg
          path: ./artifacts

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '9.0.x'


      - name: Publish to NuGet
        id: publish_nuget
        env:
          NUGET_API_KEY: ${{ secrets.NUGET_API_KEY }}
        if: ${{ env.NUGET_API_KEY != '' }}
        run: |
          dotnet nuget push artifacts/*.nupkg --api-key "$NUGET_API_KEY" --source https://api.nuget.org/v3/index.json --skip-duplicate

      - name: Tag repository with version
        if: steps.publish_nuget.outcome == 'success'
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Push tag
        if: steps.publish_nuget.outcome == 'success'
        run: |
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git config user.name "github-actions[bot]"
          git tag v${{ needs.build.outputs.version }} -f
          git push --tags --force
