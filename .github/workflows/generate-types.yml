name: Test, Generate Types and Publish Package

# This workflow ensures all tests pass before building, generating types, and publishing.
# Job execution order: version -> test -> build -> publish
# If tests fail, the build and publish jobs will not run.

on:
  push:
    branches: [ master ]
    paths-ignore:
      - 'ntoskrnlib/Generated/**'
  workflow_dispatch:
    inputs:
      version:
        description: 'Optional explicit version (overrides computed)'
        required: false
  schedule:
    - cron: '0 6 * * *'

jobs:
  version:
    name: Compute base version
    runs-on: ubuntu-latest
    outputs:
      base: ${{ steps.set.outputs.base }}
      latest: ${{ steps.set.outputs.latest }}
      label: ${{ steps.set.outputs.label }}
      explicit: ${{ steps.set.outputs.explicit }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Removed convco dependency; compute label via git log

      - name: Compute base version
        id: set
        shell: bash
        env:
          INPUT_VERSION: ${{ inputs.version }}
        run: |
          set -euo pipefail
          pkg=ntoskrnlib
          url="https://api.nuget.org/v3-flatcontainer/$pkg/index.json"

          latest_json=$(curl -fsSL "$url" 2>/dev/null || true)
          if [ -z "$latest_json" ]; then
            latest="0.0.0"
          elif command -v jq >/dev/null 2>&1; then
            latest=$(printf '%s' "$latest_json" | jq -r '[.versions[] | select(test("-")|not)][-1] // "0.0.0"')
          else
            latest=$(printf '%s' "$latest_json" | tr -d '\n\r ' | sed 's/.*"versions":\[\(.*\)\].*/\1/' | tr ',' '\n' | tr -d '"' | grep -v '-' | tail -n 1)
            latest=${latest:-0.0.0}
          fi
          label=none
          if [ "${GITHUB_EVENT_NAME}" = "push" ]; then
            git tag --list 'v*' | grep -q . || git tag v0.0.0
            last=$(git describe --tags --abbrev=0 --match 'v*' 2>/dev/null || echo v0.0.0)
            range="$last..HEAD"
            if git log --format=%s%b "$range" | grep -Ei '(^|[^A-Za-z])BREAKING CHANGE' -q \
               || git log --format=%s "$range" | grep -Ei '^[a-z]+!:' -q; then
              label=major
            elif git log --format=%s "$range" | grep -Ei '^feat(\(|:)' -q; then
              label=minor
            else
              label=none
            fi
          fi
          if [ -n "${INPUT_VERSION:-}" ]; then
            echo "explicit=true" >> $GITHUB_OUTPUT
            echo "base=$INPUT_VERSION" >> $GITHUB_OUTPUT
            echo "latest=$latest" >> $GITHUB_OUTPUT
            echo "label=$label" >> $GITHUB_OUTPUT
            exit 0
          fi
          IFS=. read -r maj min pat <<< "$latest"
          maj=${maj:-0}; min=${min:-0}; pat=${pat:-0}
          case "$label" in
            major) maj=$((maj+1)); min=0; pat=0;;
            minor) min=$((min+1)); pat=0;;
            *) :;;
          esac
          base="$maj.$min.$pat"
          echo "explicit=false" >> $GITHUB_OUTPUT
          echo "base=$base" >> $GITHUB_OUTPUT
          echo "latest=$latest" >> $GITHUB_OUTPUT
          echo "label=$label" >> $GITHUB_OUTPUT

  test:
    name: Run tests
    runs-on: windows-latest
    needs: version
    permissions:
      contents: read
    env:
      DOTNET_NOLOGO: true
      DOTNET_CLI_TELEMETRY_OPTOUT: true
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '9.0.x'

      - name: Restore dependencies
        run: dotnet restore ntoskrnlib.Tests/ntoskrnlib.Tests.csproj

      - name: Build test project
        run: dotnet build ntoskrnlib.Tests/ntoskrnlib.Tests.csproj -c Release --no-restore

      - name: Run tests
        run: dotnet test ntoskrnlib.Tests/ntoskrnlib.Tests.csproj -c Release --no-build --verbosity normal

      - name: Upload test results (on failure)
        uses: actions/upload-artifact@v4
        if: failure()
        with:
          name: test-results
          path: |
            **/TestResults/**/*.trx
            **/TestResults/**/*.log

  build:

    name: Build, generate, compare

    runs-on: windows-latest

    needs: [version, test]

    permissions:

      contents: write

      pull-requests: write

    outputs:

      version: ${{ steps.out.outputs.version }}

      changed: ${{ steps.out.outputs.changed }}

      is_new: ${{ steps.out.outputs.is_new }}

    env:

      DOTNET_NOLOGO: true

      DOTNET_CLI_TELEMETRY_OPTOUT: true

      PKG_ID: ntoskrnlib

      AUTO_APPROVE_TOKEN: ${{ secrets.AUTO_APPROVE_TOKEN }}

    steps:

      - name: Checkout

        uses: actions/checkout@v4

        with:

          fetch-depth: 0



      - name: Setup .NET

        uses: actions/setup-dotnet@v4

        with:

          dotnet-version: '9.0.x'



      - name: Prepare symbol tooling (PATH and cache)

        shell: pwsh

        run: |

          $cache = Join-Path $env:RUNNER_TEMP 'symbols'

          New-Item -ItemType Directory -Force -Path $cache | Out-Null

          "_NT_SYMBOL_PATH=srv*$cache*https://msdl.microsoft.com/download/symbols" | Out-File -Append -FilePath $env:GITHUB_ENV

          $candidates = @(

            "$Env:ProgramFiles(x86)\Windows Kits\10\Debuggers\x64",

            "$Env:ProgramFiles\Windows Kits\10\Debuggers\x64",

            "$Env:ProgramFiles(x86)\Windows Kits\10\Debuggers\x86"

          )

          foreach ($p in $candidates) { if (Test-Path $p) { $p | Out-File -Append -FilePath $env:GITHUB_PATH; Write-Host "Added to PATH: $p" } }



      - name: Attempt DIA registration (non-blocking)

        continue-on-error: true

        shell: pwsh

        run: |

          $ErrorActionPreference = 'Continue'

          function Register-Dia($dlls) {

            foreach ($dll in $dlls) {

              try {

                if (Test-Path $dll) {

                  Start-Process regsvr32.exe -ArgumentList '/s', $dll -Wait -NoNewWindow

                  Write-Host "Registered DIA: $dll"

                }

              } catch { Write-Warning "Failed to register $($dll): $_" }

            }

          }



          # Try to locate msdia140.dll in common Visual Studio locations present on hosted runners

          $search = @(

            "${Env:ProgramFiles(x86)}\Microsoft Visual Studio\2022\*\DIA SDK\bin\amd64\msdia140.dll",

            "${Env:ProgramFiles(x86)}\Microsoft Visual Studio\2022\*\Common7\IDE\msdia140.dll",

            "${Env:ProgramFiles(x86)}\Microsoft Visual Studio\2022\*\Common7\Packages\Debugger\msdia140.dll",

            "${Env:ProgramFiles(x86)}\Microsoft Visual Studio\2019\*\DIA SDK\bin\amd64\msdia140.dll"

          )

          $found = @()

          foreach ($pat in $search) { $found += Get-ChildItem -Path $pat -ErrorAction SilentlyContinue }

          if ($found) {
            Register-Dia ($found | Select-Object -ExpandProperty FullName -Unique)
          } else {
            Write-Warning 'msdia140.dll not found. Proceeding without DIA; DbgHelp path remains primary.'
          }

      - name: Build library (skip auto-generation)
        run: dotnet build ntoskrnlib\ntoskrnlib.csproj -c Release /p:WindowsVersionLabel=${{ env.WINVER_LABEL }} /p:SkipGenerateTypes=true

      - name: Generate minimal types (CI smoke)
        shell: pwsh
        run: |
          # Generate a small, reliable set of types to validate the pipeline
          dotnet run --project ntoskrnlib.Generator -- `
            --module C:\Windows\System32\ntoskrnl.exe `
            --types _EPROCESS,_KTHREAD `
            --output ntoskrnlib/Generated `
            --winver "${{ env.WINVER_LABEL }}"

          dotnet run --project ntoskrnlib.Generator -- `
            --module C:\Windows\System32\ntdll.dll `
            --types _PEB,_TEB `
            --output ntoskrnlib/Generated `
            --winver "${{ env.WINVER_LABEL }}"

      - name: Verify generated files exist
        shell: pwsh
        run: |
          $root = 'ntoskrnlib\Generated'
          $base = if ('${{ env.WINVER_LABEL }}') { Join-Path $root '${{ env.WINVER_LABEL }}' } else { $root }
          $files = Get-ChildItem $base -Recurse -Filter *.g.cs -ErrorAction SilentlyContinue
          $count = @($files).Count
          Write-Host "Generated files count: $count"
          if ($count -eq 0) { Write-Error 'No generated files found in ntoskrnlib\Generated. Failing build.'; exit 1 }
      - name: Pack with base version
        shell: pwsh
        run: |
          $verBase = '${{ needs.version.outputs.base }}'
          dotnet pack ntoskrnlib\ntoskrnlib.csproj -c Release -o artifacts /p:PackageVersion=$verBase /p:WindowsVersionLabel=${{ env.WINVER_LABEL }} /p:SkipGenerateTypes=true

      - name: Compare content and finalize version
        id: out
        shell: pwsh
        run: |
          $pkg = "$Env:PKG_ID"
          $latest = '${{ needs.version.outputs.latest }}'
          $base = '${{ needs.version.outputs.base }}'
          $explicit = '${{ needs.version.outputs.explicit }}'

          $newDll = (Get-ChildItem -Path 'ntoskrnlib\bin\Release' -Recurse -Filter 'ntoskrnlib.dll' | Sort-Object LastWriteTime -Descending | Select-Object -First 1).FullName
          $contentChanged = $true

          # If not explicitly set, bump patch if content changed and base==latest
          $final = $base
          if ($explicit -ne 'true') {
            if ($base -eq $latest -and $contentChanged) {
              $maj,$min,$pat = ($base -split '\.')
              $final = "$maj.$min.$([int]$pat + 1)"
            }
          }

          if ($final -ne $base) {
            Remove-Item artifacts\*.nupkg -Force -ErrorAction SilentlyContinue
            dotnet pack ntoskrnlib\ntoskrnlib.csproj -c Release -o artifacts /p:PackageVersion=$final /p:WindowsVersionLabel=${{ env.WINVER_LABEL }} /p:SkipGenerateTypes=true
          }

          $idx = Invoke-RestMethod -Uri ("https://api.nuget.org/v3-flatcontainer/$pkg/index.json")
          $isNew = $true
          try { $isNew = -not [bool](@($idx.versions) -contains $final) } catch { $isNew = $true }

          echo "version=$final" >> $env:GITHUB_OUTPUT
          echo "changed=$contentChanged" >> $env:GITHUB_OUTPUT
          echo "is_new=$isNew" >> $env:GITHUB_OUTPUT

      - name: Upload package artifact
        uses: actions/upload-artifact@v4
        with:
          name: nupkg
          path: artifacts/*.nupkg

      - name: Create update branch
        if: steps.out.outputs.changed == 'true'
        id: br
        shell: bash
        run: |
          ts=$(date +%Y%m%d-%H%M%S)
          br="update/generated-$ts"
          echo "name=$br" >> $GITHUB_OUTPUT
          git checkout -b "$br"

      - name: Commit generated changes (if any)
        if: steps.out.outputs.changed == 'true'
        id: commit
        shell: bash
        run: |
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git config user.name "github-actions[bot]"
          git add ntoskrnlib/Generated || true
          if git diff --cached --quiet; then
            echo "changed=false" >> $GITHUB_OUTPUT
            echo "No changes to commit"
            exit 0
          fi
          git commit -m "chore(gen): update generated sources for v${{ steps.out.outputs.version }} [skip ci]"
          git push --set-upstream origin "${{ steps.br.outputs.name }}"
          echo "changed=true" >> $GITHUB_OUTPUT

      - name: Create pull request
        if: steps.commit.outputs.changed == 'true'
        id: cpr
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          branch: ${{ steps.br.outputs.name }}
          title: "chore(gen): update generated sources for v${{ steps.out.outputs.version }}"
          body: |
            Automated update of generated sources.
            Version: `${{ steps.out.outputs.version }}`
          labels: auto-merge
          draft: false

      - name: Auto-approve pull request (optional)
        if: ${{ steps.cpr.outputs.pull-request-number && env.AUTO_APPROVE_TOKEN != '' }}
        uses: hmarr/auto-approve-action@v3
        with:
          pull-request-number: ${{ steps.cpr.outputs.pull-request-number }}
        env:
          GITHUB_TOKEN: ${{ env.AUTO_APPROVE_TOKEN }}

      - name: Enable auto-merge (optional)
        if: ${{ steps.cpr.outputs.pull-request-number && env.AUTO_APPROVE_TOKEN != '' }}
        uses: peter-evans/enable-pull-request-automerge@v3
        with:
          token: ${{ env.AUTO_APPROVE_TOKEN }}
          pull-request-number: ${{ steps.cpr.outputs.pull-request-number }}
          merge-method: squash

  publish:

    name: Publish package

    runs-on: ubuntu-latest

    needs: build

    if: ${{ needs.build.outputs.changed == 'true' && needs.build.outputs.is_new == 'true' }}

    permissions:

      contents: write

    steps:

      - name: Download package

        uses: actions/download-artifact@v4

        with:

          name: nupkg

          path: ./artifacts



      - name: Setup .NET

        uses: actions/setup-dotnet@v4

        with:

          dotnet-version: '9.0.x'



      - name: Publish to NuGet

        id: publish_nuget

        env:

          NUGET_API_KEY: ${{ secrets.NUGET_API_KEY }}

        run: |

          if [ -n "$NUGET_API_KEY" ]; then

            dotnet nuget push artifacts/*.nupkg --api-key "$NUGET_API_KEY" --source https://api.nuget.org/v3/index.json --skip-duplicate

          else

            echo "NUGET_API_KEY is not set. Skipping publish."

          fi



      - name: Tag repository with version

        if: steps.publish_nuget.outcome == 'success'

        uses: actions/checkout@v4

        with:

          fetch-depth: 0



      - name: Push tag

        if: steps.publish_nuget.outcome == 'success'

        run: |

          git config user.email "github-actions[bot]@users.noreply.github.com"

          git config user.name "github-actions[bot]"

          git tag v${{ needs.build.outputs.version }} -f

          git push --tags --force
